#pragma config(Hubs,  S2, HTMotor,  HTServo,  none,     none)
#pragma config(Sensor, S1,     forwardsTilt,   sensorI2CHiTechnicGyro)
#pragma config(Motor,  mtr_S2_C1_1,     left,          tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S2_C1_2,     right,         tmotorTetrix, PIDControl, encoder)
#pragma config(Servo,  srvo_S2_C2_1,    rearFlipper,          tServoStandard)
#pragma config(Servo,  srvo_S2_C2_2,    frontFlipper,         tServoStandard)
#pragma config(Servo,  srvo_S2_C2_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S2_C2_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S2_C2_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S2_C2_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "drivers/hitechnic-gyro.h"
#include "JoystickDriver.c"
#include "PID.c"

/*
SCHPEEEEEL on how this works
So Gyro measures the rotational velocity (to pretty good precision!).
Our goal is to keep the rotational position at 90 degrees vertical.

Therefore, PID! PID stands for Proportional, Integral, Derivative, which are the three components. Using
these three components, the algorithm decides how to act. Proportional is the current error. Most of the
correction involved is going to be looking at the current error, just because that makes sense. Integral
is more or less the average error, which helps account for things like gyro drift. Derivative is current
change in error - if you kick the balancer it'll have a sudden change in error, and Proportional will be
unable to cope, but Derivative will see a large change in error and help correct any oscillations.

Wikipedia has an even simpler and quite insightful way of explaining it: "P" corrects for current error,
"I" for past error, and "D" for future error. In that way, it will very effectively maintain balance.


*/

task gyros();
void init();
task trim();

float forwardsAngle = 0;

const int REAR_LIFT_RAISED = 240;
const int REAR_LIFT_DEPRESSED = 40;
const int FRONT_LIFT_RAISED = abs(REAR_LIFT_RAISED - 255);
const int FRONT_LIFT_DEPRESSED = abs(REAR_LIFT_DEPRESSED - 255);

float neutralAngle = 1.2;

task main()
{
	nMotorPIDSpeedCtrl[left] = mtrSpeedReg;
	nMotorPIDSpeedCtrl[right] = mtrSpeedReg;

	PID forwardsPID;
	initPID(forwardsPID,10,2,1);

	/*
 	PID forwardsPID;
 	forwardsPID.Kp = 8;
 	forwardsPID.Ki = -1; //0
 	forwardsPID.Kd = 0;
 	forwardsPID.maxIntegral = -1;
 	const float kVelocity = 0.02;
 	const float kSpeed = -0.4; //-0.4
 	const float kEncoder = -0.05; //-0.05
 	const float kSteering = 0.3;//insert DARK MAGIC

 	float forwardsOffset = 0;

 	forwardsPID.integral = 0;
 	forwardsPID.prevPosition = 0;
 	*/

	bool running = true;

	init();//Stands up and starts gyro task.

	//forwardsPID.integral = 0;
	//waitForStart();
	StartTask(trim);
	float leftOutput, rightOutput;
	float leftTarget = 0;
 	while(true)
 	{
 		nxtDisplayCenteredTextLine(2, "trim: %f", neutralAngle);
 		if(forwardsAngle < -70 || forwardsAngle > 70) {//If it fell over
 			init();
 			reset(forwardsPID);
 			//forwardsPID.integral = 0;
 		}

 		if(running) {
	 		getJoystickSettings(joystick);

	 		/*if(abs(joystick.joy1_y1)<10)
				joystick.joy1_y1 = 0;
			if(abs(joystick.joy1_x2)<10)
				joystick.joy1_x2 = 0;*/

			/*
			if(joystick.joy1_y1 > 50) {
				servo[rearFlipper] = REAR_LIFT_RAISED - 50;
			}
			else{
				servo[rearFlipper] = REAR_LIFT_RAISED;
			}
			if(joystick.joy1_y1 < -50) {
 				servo[frontFlipper] = FRONT_LIFT_RAISED + 50;
 			}
 			else {
 				servo[frontFlipper] = FRONT_LIFT_RAISED;
 			}*/

			//forwardsOffset =  -0.005*joystick.joy1_y1;
			//forwardsOffset = 0;
			float leftOutput, rightOutput;
	 			leftOutput = rightOutput = updatePID(forwardsPID, neutralAngle - forwardsAngle);//, forwardsAngle);
	 				//+ HTGYROreadRot(forwardsTilt) * kVelocity;
	 			//leftOutput += kSpeed * leftOutput;
	 			//leftOutput += forwardsPID.Kp * forwardsOffset;
				//leftOutput += kEncoder * (0 - nMotorEncoder[left]);
				/*rightOutput += kEncoder * (0 - nMotorEncoder[right]);*/

				//if(abs(leftOutput) > 100)
	 			//	leftOutput = sgn(leftOutput) * 100;
	 			//if(rightOutput > 30)
	 			//	rightOutput = 30;

	 			motor[left] = leftOutput;
	 			motor[right] = leftOutput;
	 			wait1Msec(5);
		}
 	}
}

task trim() {
	while(true) {
		if(joy1Btn(4)) {
			neutralAngle--;
			while(joy1Btn(4));
		}
		if (joy1Btn(2)) {
			neutralAngle++;
			while(joy1Btn(2));
		}
	}
	wait1Msec(5);
}

task gyros() {//Updates the forwardsAngle variable with the current deviation from 90 degrees.
	float curRateForwards = 0;
	float curRateSide = 0;
	float delTime = 0;
	nSchedulePriority = kHighPriority;

	while(true) {
		time1[T1] = 0;
		curRateForwards = HTGYROreadRot(forwardsTilt);
		if (abs(curRateForwards) > 3) {
		  forwardsAngle += curRateForwards * delTime; //Approximates the next heading by adding the rate*time.
		}
		wait1Msec(5);
		delTime = ((float)time1[T1]) / 1000; //set delta (zero first time around)
	}
}
void init() {
	motor[left] = 0;
	motor[right] = 0;

	servo[rearFlipper] = REAR_LIFT_DEPRESSED;
 	servo[frontFlipper] = FRONT_LIFT_DEPRESSED;
 	wait1Msec(2700);
 	StopTask(gyros);
 	PlaySound(soundBeepBeep);
	HTGYROstartCal(forwardsTilt);
 	wait1Msec(1000);
	PlaySound(soundBeepBeep);
	forwardsAngle = 0;
	StartTask(gyros);
 	wait1Msec(200);
	nMotorEncoder[left] = 0;
	nMotorEncoder[right] = 0;
	servo[rearFlipper] = REAR_LIFT_RAISED;
 	servo[frontFlipper] = FRONT_LIFT_RAISED;
}
