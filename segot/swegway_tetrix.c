#pragma config(Hubs,  S2, HTMotor,  HTServo,  none,     none)
#pragma config(Sensor, S1,     forwardsTilt,   sensorI2CHiTechnicGyro)
#pragma config(Motor,  mtr_S2_C1_1,     left,          tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S2_C1_2,     right,         tmotorTetrix, PIDControl, encoder)
#pragma config(Servo,  srvo_S2_C2_1,    rearFlipper,          tServoStandard)
#pragma config(Servo,  srvo_S2_C2_2,    frontFlipper,         tServoStandard)
#pragma config(Servo,  srvo_S2_C2_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S2_C2_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S2_C2_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S2_C2_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "drivers/hitechnic-gyro.h"
#include "JoystickDriver.c"
#include "PID.c"

/*
SCHPEEEEEL on how this works
So Gyro measures the rotational velocity (to pretty good precision!).
Our goal is to keep the rotational position at 90 degrees vertical.

Therefore, PID! PID stands for Proportional, Integral, Derivative, which are the three components. Using
these three components, the algorithm decides how to act. Proportional is the current error. Most of the
correction involved is going to be looking at the current error, just because that makes sense. Integral
is more or less the average error, which helps account for things like gyro drift. Derivative is current
change in error - if you kick the balancer it'll have a sudden change in error, and Proportional will be
unable to cope, but Derivative will see a large change in error and help correct any oscillations.

Wikipedia has an even simpler and quite insightful way of explaining it: "P" corrects for current error,
"I" for past error, and "D" for future error. In that way, it will very effectively maintain balance.
*/

//Forward declarations
task gyros();
void init();
task steer();

//Degree headings for 180-degree "lift" servos
const int REAR_LIFT_RAISED = 240;
const int REAR_LIFT_DEPRESSED = 40;
const int FRONT_LIFT_RAISED = abs(REAR_LIFT_RAISED - 255);
const int FRONT_LIFT_DEPRESSED = abs(REAR_LIFT_DEPRESSED - 255);

const int maxNeutral = 20; //Maximum 20 degrees offset for driving.

//Degrees
float forwardsAngle = 0;
float leftNeutral = 0;
float rightNeutral = 0;

task main() {
	//Set up precision speed control (which, incidentally, uses PID to do it :D)
	nMotorPIDSpeedCtrl[left] = mtrSpeedReg;
	nMotorPIDSpeedCtrl[right] = mtrSpeedReg;
	
	//Initialize PIDs.
	PID leftPID,rightPID;
	initPID(leftPID,10,2,1);
	initPID(rightPID,10,2,1);
	
	//Stands up and initiates gyro stuff.
	init();
	
	waitForStart();
	
	//Initialize steering, raise arms... let's start!!
	StartTask(steer);
	servo[rearFlipper] = REAR_LIFT_RAISED;
	servo[frontFlipper] = FRONT_LIFT_RAISED;
	
 	while(true) {
		if(abs(forwardsAngle) > 70) {//If it fell over, redo.
 			reset(leftPID);
			reset(rightPID);
			init();
			servo[rearFlipper] = REAR_LIFT_RAISED;
			servo[frontFlipper] = FRONT_LIFT_RAISED;
 		}
		
		//Separate left and right PIDs to allow steering.
		motor[left] = updatePID(leftPID, leftNeutral - forwardsAngle);
		motor[right] = updatePID(rightPID, rightNeutral - forwardsAngle);
		
		wait1Msec(5);
 	}
}

task steer() {//Uses joyBtns to change speed by adjusting neutral-points for left and right.
	while(true) {
		getJoystickSettings(joystick);
		
		//Neutralize joystick drift (when you release it you expect it to be zero, but it apparently isn't)
		if(abs(joystick.joy1_y1) < 10)
			joystick.joy1_y1 = 0;
		if(abs(joystick.joy1_x1) < 10)
			joystick.joy1_x1 = 0;
		
		//Joysticks are from -128 to +127.
		//(Single-joystick drive)
		leftNeutral = (joystick.joy1_y1 + joystick.joy1_x1) * maxNeutral / 128.0;
		rightNeutral = (joystick.joy1_y1 - joystick.joy1_x1) * maxNeutral / 128.0;
	}
	wait1Msec(5);
}

task gyros() {//Updates the forwardsAngle global variable (degrees) with the current deviation from 90 degrees.
	nSchedulePriority = kHighPriority;
	INTR intr;//Integrator.
	init(intr);
	
	forwardsAngle = 0;
	
	while(true) {
		forwardsAngle = integrate(intr, /*Degrees/sec rotational velocity*/ HTGYROreadRot(forwardsTilt));
			//Trapezoidal-approximation integrating degrees/sec to get degrees.
		wait1Msec(5);
	}
}

void init() {
	//Stop.
	motor[left] = 0;
	motor[right] = 0;
	
	//Stand up.
	servo[rearFlipper] = REAR_LIFT_DEPRESSED;
	servo[frontFlipper] = FRONT_LIFT_DEPRESSED;
	
	//Wait for it to stand all the way up.
	wait1Msec(2700);
	
	//Recalibrate the gyro.
	StopTask(gyros);
	PlaySound(soundBeepBeep);
	HTGYROstartCal(forwardsTilt);
	wait1Msec(1000);//Give it time to calibrate
	PlaySound(soundBeepBeep);
	
	//K finished with gyro calibration.
	StartTask(gyros);
	nMotorEncoder[left] = 0;//Not sure what these two lines are for.
	nMotorEncoder[right] = 0;
}
