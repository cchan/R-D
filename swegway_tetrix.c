#pragma config(Hubs,  S2, HTMotor,  HTServo,  none,     none)
#pragma config(Sensor, S1,     forwardsTilt,   sensorI2CHiTechnicGyro)
#pragma config(Motor,  mtr_S2_C1_1,     left,          tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S2_C1_2,     right,         tmotorTetrix, PIDControl, encoder)
#pragma config(Servo,  srvo_S2_C2_1,    rearFlipper,          tServoStandard)
#pragma config(Servo,  srvo_S2_C2_2,    frontFlipper,         tServoStandard)
#pragma config(Servo,  srvo_S2_C2_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S2_C2_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S2_C2_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S2_C2_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "drivers/hitechnic-gyro.h"
#include "JoystickDriver.c"
#include "PID.c"
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

task gyros();
void init();
task trim();

float forwardsAngle = 0;

const int REAR_LIFT_RAISED = 240;
const int REAR_LIFT_DEPRESSED = 40;
const int FRONT_LIFT_RAISED = abs(REAR_LIFT_RAISED - 255);
const int FRONT_LIFT_DEPRESSED = abs(REAR_LIFT_DEPRESSED - 255);

float neutralAngle = 1.2;

task main()
{
	nMotorPIDSpeedCtrl[left] = mtrSpeedReg;
	nMotorPIDSpeedCtrl[right] = mtrSpeedReg;
 	PID forwardsPID;
 	forwardsPID.Kp = 8; //8
 	forwardsPID.Ki = 0;
 	forwardsPID.Kd = 0;
 	forwardsPID.maxIntegral = -1;
 	const float kVelocity = 0.02;
 	const float kSpeed = -0.4; //-0.4
 	const float kEncoder = -0.05; //-0.05
 	const float kSteering = 0.3;//insert DARK MAGIC

 	float forwardsOffset = 0;

 	forwardsPID.integral = 0;
 	forwardsPID.prevPosition = 0;

	bool running = true;

	init();
	forwardsPID.integral = 0;
	//waitForStart();
	StartTask(trim);
	float leftOutput, rightOutput;
	float leftTarget = 0;
 	while(true)
 	{
 		nxtDisplayCenteredTextLine(2, "trim: %f", neutralAngle);
 		if(forwardsAngle < -70) {
 			init();
 			forwardsPID.integral = 0;
 		}
 		else if(forwardsAngle > 70) {
 			init();
 			forwardsPID.integral = 0;
 		}

 		if(running) {
	 		getJoystickSettings(joystick);

	 		/*if(abs(joystick.joy1_y1)<10)
				joystick.joy1_y1 = 0;
			if(abs(joystick.joy1_x2)<10)
				joystick.joy1_x2 = 0;*/

			if(joystick.joy1_y1 > 50) {
				servo[rearFlipper] = REAR_LIFT_RAISED - 50;
			}
			else{
				servo[rearFlipper] = REAR_LIFT_RAISED;
			}
			if(joystick.joy1_y1 < -50) {
 				servo[frontFlipper] = FRONT_LIFT_RAISED + 50;
 			}
 			else {
 				servo[frontFlipper] = FRONT_LIFT_RAISED;
 			}

			//forwardsOffset =  -0.005*joystick.joy1_y1;
			forwardsOffset = 0;

	 			leftOutput = rightOutput  = updatePID(forwardsPID, neutralAngle - forwardsAngle, forwardsAngle) +
	 				HTGYROreadRot(forwardsTilt) * kVelocity;
	 			leftOutput += kSpeed * leftOutput;
	 			//leftOutput += forwardsPID.Kp * forwardsOffset;
					leftOutput += kEncoder * (0 - nMotorEncoder[left]);
				/*rightOutput += kEncoder * (0 - nMotorEncoder[right]);*/
	 			if(abs(leftOutput) > 100)
	 				leftOutput = sgn(leftOutput) * 100;
	 			if(rightOutput > 30)
	 				rightOutput = 30;

	 			motor[left] = leftOutput;
	 			motor[right] = leftOutput;
	 			wait1Msec(5);
		}
 	}
}

task trim() {
	while(true) {
		if(joy1Btn(4)) {
			neutralAngle--;
			while(joy1Btn(4));
		}
		if (joy1Btn(2)) {
			neutralAngle++;
			while(joy1Btn(2));
		}
	}
	wait1Msec(5);
}
task gyros() {
	float curRateForwards = 0;
	float curRateSide = 0;
	float delTime = 0;
	nSchedulePriority = kHighPriority;

	while(true) {
		time1[T1] = 0;
    curRateForwards = HTGYROreadRot(forwardsTilt);
    if (abs(curRateForwards) > 3) {
      forwardsAngle += curRateForwards * delTime; //Approximates the next heading by adding the rate*time.
  	}
  	wait1Msec(5);
    delTime = ((float)time1[T1]) / 1000; //set delta (zero first time around)
	}
}
void init() {
	motor[left] = 0;
	motor[right] = 0;

	servo[rearFlipper] = REAR_LIFT_DEPRESSED;
 	servo[frontFlipper] = FRONT_LIFT_DEPRESSED;
 	wait1Msec(2700);
 	StopTask(gyros);
 	PlaySound(soundBeepBeep);
	HTGYROstartCal(forwardsTilt);
 	wait1Msec(1000);
	PlaySound(soundBeepBeep);
	forwardsAngle = 0;
	StartTask(gyros);
 	wait1Msec(200);
	nMotorEncoder[left] = 0;
	nMotorEncoder[right] = 0;
}
