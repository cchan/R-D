#pragma config(Sensor, S1,     forwardsTilt,   sensorI2CHiTechnicGyro)
#pragma config(Motor,  motorB,          left,          tmotorNXT, openLoop, encoder)
#pragma config(Motor,  motorC,          right,         tmotorNXT, openLoop, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "drivers/hitechnic-gyro.h"
#include "../lib/PID.h"
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

task gyros();

int targetOffset = 0;
int swingTarget = 0;
float forwardsAngle = 0;
float sideAngle = 0;

task main()
{
	HTGYROstartCal(forwardsTilt);
 	wait1Msec(1000);

 	//PlaySound(soundBeepBeep);
	PlaySound(soundBlip);
 	StartTask(gyros);

 	PID forwardsPID;
 	forwardsPID.Kp = 35.0;
 	forwardsPID.Ki = 0;
 	forwardsPID.Kd = 0;
 	const float kVelocity = -5.0;
 	const float kEncoder = 0.1;

 	float leftTarget = -360;
 	float rightTarget = -360;

 	float neutralAngle = -92;
 	forwardsPID.integral = 0;
 	forwardsPID.prevPosition = 0;

 	nMotorEncoder[left] = 0;
 	while(nNxtButtonPressed!=3);
 	while(true)
 	{
 		if(nNxtButtonPressed == 3) {
 			neutralAngle = forwardsAngle;
 			forwardsPID.integral = 0;
 			nMotorEncoder[left] = 0;
 			nMotorEncoder[right] = 0;
 			//motor[left] = 0;
 			//motor[right] = 0;
 		}

 			float output = updatePID(forwardsPID, neutralAngle - forwardsAngle, forwardsAngle) +
 				HTGYROreadRot(forwardsTilt) * kVelocity;

 			float outputLeft = output + (leftTarget - nMotorEncoder[left]) * kEncoder;
 			float outputRight = output + (rightTarget - nMotorEncoder[right]) * kEncoder;

 			if(outputLeft == 0)
 				outputLeft = 50;
 			if(outputRight == 0)
 				outputRight = 50;

 			nxtDisplayCenteredTextLine(2,  "%f", output);
 			nxtDisplayCenteredTextLine(3, "%d , %d", nMotorEncoder[left], nMotorEncoder[right]);

 			motor[left] = outputLeft;
 			motor[right] = outputRight;
 			nxtDisplayCenteredTextLine(2, "%d", motor[left]);

 		wait1Msec(5);
 	}
}

task gyros() {
	float curRateForwards = 0;
	float curRateSide = 0;
	float delTime = 0;
	nSchedulePriority = kHighPriority;

	while(true) {
		time1[T1] = 0;
    curRateForwards = HTGYROreadRot(forwardsTilt);
    if (abs(curRateForwards) > 3) {
      forwardsAngle += curRateForwards * delTime; //Approximates the next heading by adding the rate*time.
  	}
  	wait1Msec(5);
    delTime = ((float)time1[T1]) / 1000; //set delta (zero first time around)
	}
}
